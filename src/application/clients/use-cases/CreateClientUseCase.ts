import { Client } from '@/domain/clients/entities/Client'
import { IClientRepository } from '@/domain/clients/repositories/IClientRepository'
import { CreateClientDTO, ClientDTO } from '../dto'
import { Email, Phone, Website, ClientName, AgencyName } from '@/domain/clients/value-objects'
import { ClientStatus } from '@prisma/client'
import { UserContext } from '@/application/shared/types/UserContext'
import { db } from '@/lib/db'

/**
 * Use case for creating a new client
 */
export class CreateClientUseCase {
  constructor(private readonly clientRepository: IClientRepository) {}

  async execute(dto: CreateClientDTO, user: UserContext): Promise<ClientDTO> {
    // Create value objects
    const firstName = ClientName.create(dto.firstName, 'ImiÄ™', 1, 50)
    const lastName = ClientName.create(dto.lastName, 'Nazwisko', 1, 50)
    const agencyName = AgencyName.create(dto.agencyName)
    const email = Email.create(dto.email)
    const phone = Phone.create(dto.phone)
    const website = Website.create(dto.website)

    // Create client entity (ID will be generated by Prisma)
    const client = Client.create({
      id: '', // Empty ID, will be generated by Prisma
      firstName,
      lastName,
      agencyName,
      email,
      phone,
      website,
      address: dto.address || null,
      source: dto.source || null,
      status: dto.status || ClientStatus.NEW_LEAD,
      priority: dto.priority || null,
      assignedTo: dto.assignedTo || null,
      nextFollowUpAt: dto.nextFollowUpAt ? new Date(dto.nextFollowUpAt) : null,
    })

    // Save client
    const savedClient = await this.clientRepository.create(client)

    // Create status history entry
    await db.clientStatusHistory.create({
      data: {
        clientId: savedClient.getId(),
        status: savedClient.getStatus(),
        changedBy: user.id,
        notes: 'Utworzenie klienta',
      },
    })

    // Log activity
    await db.activityLog.create({
      data: {
        userId: user.id,
        action: 'CLIENT_CREATED',
        entityType: 'Client',
        entityId: savedClient.getId(),
        details: {
          agencyName: savedClient.getAgencyName().getValue(),
          status: savedClient.getStatus(),
        },
      },
    })

    // Update additional fields that are not in the domain entity
    const additionalFields: any = {}
    if (dto.type !== undefined) additionalFields.type = dto.type
    if (dto.companyName !== undefined) additionalFields.companyName = dto.companyName
    if (dto.taxId !== undefined) additionalFields.taxId = dto.taxId
    if (dto.regon !== undefined) additionalFields.regon = dto.regon
    if (dto.pesel !== undefined) additionalFields.pesel = dto.pesel

    if (Object.keys(additionalFields).length > 0 || (dto.sharedGroupIds && dto.sharedGroupIds.length > 0)) {
      await db.client.update({
        where: { id: savedClient.getId() },
        data: {
          ...additionalFields,
          ...(dto.sharedGroupIds && dto.sharedGroupIds.length > 0 ? {
            sharedGroups: {
              connect: dto.sharedGroupIds.map((id) => ({ id })),
            },
          } : {}),
        },
      })
    }

    return this.toDTO(savedClient)
  }

  private toDTO(client: Client): ClientDTO {
    return {
      id: client.getId(),
      firstName: client.getFirstName().getValue(),
      lastName: client.getLastName().getValue(),
      agencyName: client.getAgencyName().getValue(),
      email: client.getEmail()?.getValue() || null,
      phone: client.getPhone()?.getValue() || null,
      website: client.getWebsite()?.getValue() || null,
      address: client.getAddress(),
      source: client.getSource(),
      status: client.getStatus(),
      priority: client.getPriority(),
      assignedTo: client.getAssignedTo(),
      lastContactAt: client.getLastContactAt(),
      nextFollowUpAt: client.getNextFollowUpAt(),
      createdAt: client.getCreatedAt(),
      updatedAt: client.getUpdatedAt(),
    }
  }
}

